<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
		which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
                           "http://xml.resource.org/authoring/rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
		There has to be one entity for each item to be referenced.
		An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3236 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3236.xml">
<!ENTITY RFC3870 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3870.xml">
<!ENTITY RFC4452 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4452.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC5988 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5988.xml">
<!ENTITY RFC6838 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6838.xml">
<!ENTITY RFC6906 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6906.xml">
<!ENTITY RFC7230 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7240 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7240.xml">
<!ENTITY RFC8141 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8141.xml">
<!ENTITY RFC8288 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8288.xml">
<!ENTITY SHACL SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml-w3c/reference.W3C.REC-shacl-20170720.xml">
<!ENTITY XSD SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml-w3c/reference.W3C.REC-xmlschema11-1-20120405.xml">
<!ENTITY I-D.nottingham-link-hint SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nottingham-link-hint.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
		please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
		(Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc symrefs="yes" ?>

<rfc category="info" docName="draft-svensson-profiled-representations-01" ipr="trust200902">
	<!-- ***** FRONT MATTER ***** -->

	<front>
		<!-- The abbreviated title is used in the page header - it is only necessary if the
				full title is longer than 39 characters -->

		<title abbrev="Handling Profiled Representations">Indicating, Discovering, and Negotiating Profiled Representations</title>


		<author fullname="Lars G. Svensson" initials="L.G." surname="Svensson">
			<address>
				<email>lars.svensson@web.de</email>
				<uri>https://orcid.org/0000-0002-8714-9718</uri>
			</address>
		</author>

		<author fullname="Ruben Verborgh" initials="R." surname="Verborgh">
			<organization>Ghent University &#8211; imec</organization>
			<address>
				<postal>
					<street>Sint-Pietersnieuwstraat 41</street>
					<code>9000</code>
					<city>Ghent</city>
					<region/>
					<country>Belgium</country>
				</postal>
				<phone>+32 9 331 49 10</phone>
				<email>ruben.verborgh@ugent.be</email>
				<uri>https://ruben.verborgh.org/</uri>
			</address>
		</author>
		<author initials="H." surname="Van de Sompel" fullname="Herbert Van de Sompel">
			<organization>Data Archiving and Networked Services</organization>
			<address>
				<postal>
					<street>Anna van Saksenlaan 51</street>
					<code>2593 HW</code>
					<city>The Hague</city>
					<region/>
					<country>Netherlands</country>
				</postal>
				<email>herbert.van.de.sompel@dans.knaw.nl</email>
				<uri>https://orcid.org/0000-0002-0715-6126</uri>
			</address>
		</author>

		<date month="March" year="2021"/>

		<!-- Meta-data Declarations -->

		<area>General</area>

		<workgroup>Internet Engineering Task Force</workgroup>

		<!-- WG name at the upperleft corner of the doc,
				IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
				which is used by the RFC Editor as a nod to the history of the IETF. -->



		<abstract>
			<t>This document defines two new HTTP headers: "Accept-Profile" and "Content-Profile".
				Accept-Profile can be used by user agents to request a preferred profile for representing
				a resource from a server. Content-Profile is used by servers to express the profile
				that was applied to represent a resource.
				In this context, a profile is a description of
				structural and/or semantic constraints on representations of resources
				in addition to the syntactical interpretation provided by their MIME type.
				Examples of profiles include Dublin Core Application Profiles, XML Schemata, and
				RDF Shape Expressions.
				This document further defines the "profile" attribute for HTTP Links and suggests
				a best practice for the use of the new headers in conjunction with the HTTP "Link"
				header as a means to point clients to representations that adhere to profiles other
				than the one used for the current representation.</t>
		</abstract>
	</front>

	<middle>
		
		<section title="Introduction">
			<t>On the Web, resources are identified by HTTP(S) URIs. User agents retrieve a representation
				of a resource by issuing a GET request on its URI. To accomodate different user agents and use cases,
				a server can support multiple representations for a same resource. Content negotiation is an approach
				that allows a user agent to express a preference for certain representations when issuing a GET request.
				For example, a user agent can specify a preferences for a media type by using the "Accept" header
				with an associated value, and for langauge by using the "Accept-Language" header with a value.
				A server responds to such a request by using matching HTTP headers and associated values to convey the nature of the
				representation it delivers, e.g. "Content-Type" and "Content-Language", respectively, as well as an
				indication of the dimensions in which it supports content negotiation using the "Vary" header.
				This document defines two new HTTP headers
				that enable user agents and servers to negotiate about a
				profile for representing a specific resource.
			</t>
			<section title="Motivation">
				<t>In many cases, there are several ways to render a resource
					within the scope of a certain media type.
					For example, for XML documents the same content can be encoded
					on the basis of several DTDs or XML Schemas.
					Similarly, JSON documents offer a wide range of options
					regarding the use of tree structure, keys, and value types.
					And, in RDF serializations, a choice of vocabularies is available
					to describe resources of the same kind.
					However, when a user agent initiates a GET request to retrieve a resource representation
					or a PUT request to create/replace a resource representation, no means are available to express
					the precise rendering of the representation beyond its media type.
					To address this shortcoming, this document
					defines the HTTP request header "Accept-Profile" and the corresponding HTTP response header
					"Content-Profile".</t>
			</section> <!-- End section motivation -->
			<section title="Terminology">
			
				<t>Inspired by the term used in <xref target="RFC6906"/> to refer to this extra dimension of variability, this document uses the term "profile" to mean a description of
				structural and/or semantic constraints on representations of resources that apply 
				in addition to the constraints inherently indicated by their MIME type:</t>
			<t><list style="symbols">
				<t>Profiles can be dependent on a media type. For example, this is the case for XML, with constraints being expressed using an XML Schema. 
					This is also the case for JSON that offers a wide range of options regarding the use of tree structure, keys, and value types.
					In these cases, the meaning of the term "profile" intended by this document coincides with the use of the same term in <xref target="RFC6906"/>.</t>
				<t>Profiles can be independent of media type. For example, this is the case for RDF graphs that can be rendered according to various media types,
					while constraints can be expressed in a manner that is independent of media type, among others, using <xref target="W3C.REC-shacl-20170720">SHACL</xref>.
					In these cases, the meaning of the term "profile" intended by this document is a slight extension of the one intended by <xref target="RFC6906"/>.</t>
			</list></t>
			
			</section> <!-- End section terminology -->
			
			<section title="Purpose" anchor="why">
			
				<t>When it comes to HTTP interactions, profiles have received little attention despite their de facto existence and 
				the added-value they can bring for building rich applications. Such applications benefit from knowledge regarding the nature of a representation 
				that a client obtains from a server, that a client sends to a server, and that a server is willing to accept from a client,  
				beyond what is conveyed by the representation's MIME type. 
				These applications are also be helped by an ability to discover representations rendered according to a profile they can handle, or, 
				optimally, an ability to explicitly request a rendering according to a preferred profile. 
			</t>
				
				<t>A common approach to handle profiles is to register them as a media type, dedicated to the combination of an actual media type 
					and a profile of it. Media types that illustrate this approach include "application/activity+json", "application/calendar+json", and "application/calendar+xml. 
					This approach allows conveying all necessary profile information in HTTP interactions, e.g. using the "Accept" and "Content-Encoding" HTTP headers
					and the "type" attribute for web links. As such it supports indicating, discovering, and  content negotiating (in the media type dimension) for profiled representations. 
					This registration-based approach may be feasible for 
				    profiles that are expected to be very widely used but is not practical in case support for many different profiles is required. 
				    Also, the "calendar" examples illustrate 
				    that the registration-based approach is not ideal when a profile applies to multiple media types. 
				    And, the "activity" example illustrates that 
				    the approach supports indicating what the major ingredient of a profiled representation is (i.e. the ActivityStreams Vocabulary) but becomes problematic 
				    when indications are also needed regarding additional vocabularies used in representations.
				</t>
				
				<t>Another approach to handle profiles leverages the ability provided by <xref target="RFC6838"/> to register parameters when registering a media type. 
					Some media types have used this capability to register an attribute dedicated to conveying profiles of the media type. For example, for "application/ld+json" 
					the "profile" parameter has been registered for this purpose. The approach provides flexibility for handling many profiles, 
					including ones that are not yet known when registering the media type.
					It also supports indicating, discovering, and content negotiating (in the media type dimension) for profiled representations using common approaches. 
					But the approach remains problematic because it ties profile information to a media type, depends on registering a parameter to convey profile information 
					when registering a new media type, and, realistically, on the registration of the same parameter name (i.e. "profile" as suggested in <xref target="RFC6906"/>) 
					for all media types for which registrants deem that conveying profile information is important. 
					Additionaly, <xref target="RFC6838"/> discourages registering parameters for previously registered media types, making it highly questionable that a uniform attribute 
					to convey profile information across all media types could retroactively be defined.</t>
				
				<t>Recognizing the importance of profiles and the problems with the aforementioned approaches to handle them, 
					specifications have started to introduce alternative approaches to express information about 
					resource representation profiles in HTTP interactions:</t>
				<t><list style="symbols">
					<t><xref target="RFC6906"/> introduces the "profile" link relation type that is generally 
						applicable for indicating the profile of a resource representation that is sent by a client to a server or by a server to a client. 
					</t> 
					<t><xref target="I-D.nottingham-link-hint"/> introduces a capability to make profiled representations discoverable via web links by using the "formats" 
						attribute to express the profile of a linked resource.
					</t>
				</list></t>
					
				<t><xref target="Indicating"/> and <xref target="Discovering"/> 
					provide a concise overview of the approaches introduced by <xref target="RFC6906"/> and <xref target="I-D.nottingham-link-hint"/>,   
					to respectively indicate and discover the profile of resource representations. 
					<xref target="Negotiating"/> specifies a generally applicable approach to negotiate for representations that conform to a profile preferred by a user agent
					and also shows how servers can convey which profiled representations they are able to accept from user agents.

				</t>

			</section> <!-- End section Purpose -->
		
			<section title="Notational Conventions">
				
				<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
					"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
					document are to be interpreted as described in <xref
						target="RFC2119">RFC 2119</xref>.</t>
				
				<t>This specification uses the terms "link context" and "link target" as defined in <xref target="RFC8288"/>. 
					These terms respectively correspond with "Context IRI" and "Target IRI" as used in <xref target="RFC5988"/>. 
					Although defined as IRIs, in common scenarios they are also URIs.</t>
				
				<t>In the examples provided in this document, links in the HTTP "Link" header are shown on separate lines in order to improve readability. 
					Note, however, that as per Section 3.2 of <xref target="RFC7230"/>, line breaks are not allowed in values for HTTP headers; only whitespaces and 
						tabs are supported as seperators.
				</t>
				
			</section> <!-- End section notational conventions -->
			
		</section> <!-- end section Introduction -->
		

			
		<section title="Indicating Profiled Representations" anchor="Indicating">
				
				<t>As per <xref target="RFC6906"/>, a web link with a "profile" link relation type can be used to 
					indicate the profile of a representation that is exchanged in HTTP interactions. <xref target="request_SI1"/> shows a client requesting a
					representation from a server and <xref target="response_SI1"/> shows the server responding. The response includes a "Link" header 
					(<xref target="RFC8288"/>) that  contains a link with the "profile" relation type. 
					The link target &lt;http://purl.org/dc/terms/&gt; indicates the profile of 
					the response body (not shown).
				</t>
					<t><xref target="request_UI1"/> shows a client submitting a representation to a server, 
				    using the same approach to express the profile to which that representation complies.
						<xref target="Negotiating"/> describes how a server can convey the profiles it supports 
						for representations that are submitted by a user agent.
					</t>
				
				<figure title="Client requests a representation" align="center" anchor="request_SI1">
					<artwork align="left"><![CDATA[ 
GET /some/resource HTTP/1.1
Host: example.org
Connection: close
						]]>
					</artwork>
				</figure>
	
				<figure title="Server indicates the profile of the returned representation" align="center" anchor="response_SI1">
					<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: application/xml ; charset=utf-8
Link: <http://purl.org/dc/terms/>; rel="profile"
Content-Length: 23364
Connection: close

...
						]]>
					</artwork>
				</figure>
				
				<figure title="Client indicates the profile of a representation submitted to a server" align="center" anchor="request_UI1">
					<artwork align="left"><![CDATA[ 
PUT /some/resource HTTP/1.1
Host: example.org
Content-Type: application/xml ; charset=utf-8
Link: <http://purl.org/dc/terms/>; rel="profile"
Content-Length: 23364
Connection: close

...
						]]>
					</artwork>
				</figure>
			
				<t>In some cases organisations use separate servers to perform content negotiation and to deliver resources,
					e. g. when static content is served through content delivery networks.
					The servers that perform the content negotiation interact with the client requesting the resource
					and then typically refer to the correct representation using a 303 redirect.
					In those cases the servers that deliver the representations are not profile aware
					and thus cannot add the appropriate "Link" headers to the response.
					Instead the server performing the negotiation will have to supply that information.
					This is done by adding an "anchor" attribute pointing to the representation the link header refers to.
					<xref target="response_RI1"/> shows the response to a <xref target="request_SI1"/>
					where the server performing the negotiation redirects the client to the resource specified in the
					"Location" header and by using the same URI in the "anchor" attribute of the "Link" header
					indicates that the information in the "Link" header does not apply to this response
					but to the resource redirected to.
				</t>
				<figure title="Server indicates the profile of the representation referred to in the 'Location' header" align="center" anchor="response_RI1">
					<artwork align="left"><![CDATA[ 
HTTP/1.1 300 See other
Location: https://static.example.org/other/resource
Link: <http://purl.org/dc/terms/>; rel="profile"
        ; anchor="https://static.example.org/other/resource"

...
						]]>
					</artwork>
				</figure>
		</section> <!-- end sdction indicating -->
			
		<section title="Discovering Profiled Representations" anchor="Discovering">
				
				<t>The link hints capability introduced in <xref target="I-D.nottingham-link-hint"/>, can be leveraged by a server to make profiled representations discoverable by 
					including a "formats" attribute on web links. <xref target="response_SI1"/> shows a response to the client request of 
					<xref target="request_SI1"/> in which the server uses this technique. The "Link" header indicates the profile of the returned representation 
					but also points at two alternative representations, each of which conforms to another profile.
				</t>

			<section title="Content-Location">
				<t>
					The <xref target="RFC7231">"Content-Location" header</xref>
					can be used to provide an identifier
					for the specific representation of a resource
					that is enclosed in the message body.
					For example, when a user agent issues the following request
					for /some/resource:
					</t>
					<figure>
<artwork align="left">
GET /some/resource HTTP/1.1
Accept: application/ld+json;
        profile="https://www.w3.org/ns/activitystreams"
</artwork>
					</figure>
					<t>The server might reply with:</t>
					<figure>
<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: application/xml
Link: <http://purl.org/dc/terms/> ; rel="profile" , 
      </some/other_resource_1> 
         ; rel="alternate" ; type="application/xml" 
         ; formats="http://example.org/our_internal_xml_profile" ,
      </some/other_resource_2>
         ; rel="alternate" 
         ; formats="http://example.org/our_community_profile" 
Content-Length: 23364
Connection: close

...
]]>
					</artwork>
				</figure>

			</section> <!-- end section content-location -->
		</section> <!-- end section discovering -->

		<section title="New HTTP Headers">
			<t>The "Content-Profile" and "Accept-Profile" header fields MAY be sent by both
				the user agent and the server.
				The "Content-Profile" header contains a non-exhaustive list
				of profiles the payload of the message conforms to,
				whereas the "Accept-Profile" header specifies
				one or more profiles the Agent accepts.
				For example, a user agent issuing a request for a resource could specify
				through the "Accept" header that it accepts representations with either
				text/turtle or application/ld+json as MIME type,
				and through the "Accept-Profile" header that
				it prefers people to be described using the FOAF vocabulary,
				but that the BBC Core ontology is also acceptable.
				When the server answers, it would set the "Content-Type"
				and "Content-Profile" header fields appropriately.
				Likewise, a user agent sending an XML document with a specific structure to a server
				could set	the "Content-Type" and the "Content-Profile" header fields.</t>
			<t>The absence of an "Accept-Profile" header field in an HTTP response
				SHOULD be taken as an indication that the server
				does not support profile-based content-negotiation for the given resource.
				It MUST NOT be seen as an indication that the server can handle payloads
				conforming to any profile.</t>
			<t>A server that fails a request due to receiving a payload with an unsupported profile
				SHOULD respond with a 415 status code
				and SHOULD include an "Accept-Profile" header in its response,
				allowing clients to distinguish between issues related to profiles and media types.
				It MAY list acceptable profiles in the message body.
				In order to avoid confusion with issues related to media types,
				servers that fail a request with a 415 status for reasons unrelated to profiles
				MUST NOT include the "Accept-Profile" header field.
			</t>
			
			<t>
			This section describes an approach that applies content negotiation in a dimension that it was previously not applied to. 
			The profile negotiation approach introduced here is generally applicable for 
			resource representations, irrespective of media type. These are its core aspects:
			</t>
			<section title="Content-Profile Header Syntax">
				<t>The "Content-Profile" header field specifies
					one or more profiles the payload in the message conforms to.
					In absence of a "Content-Profile" header,
					the user agent SHOULD NOT make any assumptions about the representation
					beyond what is specified by the media type indicated in the "Content-Type" header.
				</t>
				<t>
					In profile negotiation, a profile MUST be referred to by a URI that, from here onwards, is named a profile URI. 
					If the profile URI is dereferencable it SHOULD lead to a document that details the profile. If the profile URI 
					is not dereferencable (e.g. a <xref target="RFC8141">URN</xref> or an <xref target="RFC4452">info-URI</xref>) 
					facilities SHOULD be available to allow user agents and servers to understand their meaning, e.g. community registries of profiles.
					</t>

				<section title="Proactive Profile Negotiation" anchor="proconneg">
					
					<t>In proactive profile negotiation, the user agent uses the 
						"Accept-Profile" HTTP header to inform the server about the agent's preference 
						regarding profiles to be used for representing a resource in the server's response. 
						In case a user agent wants to express a preference for a single profile, the value of the header is that 
						profile's URI. In case a user agent wants to express a preference for multiple profiles, the value of the header is 
						a list containing each profile's URI, seperated by commas. Alternatively, multiple "Accept-Profile" HTTP headers can be used, 
						each conveying a single profile URI. Quality indicators (q-values) MAY be used to rank profile preferences.
						The order in which profile URIs are conveyed or the duplicate mentioning of a same profile URI 
						MUST NOT be interpreted as significant.
					</t>
					
					<t>A server that supports proactive profile negotiation for the resource that a user agent  
						interacts with:
					</t>
					<t><list style="symbols">
						<t>MUST include a "Vary" HTTP header containing the value "accept-profile" in its response to the user agent.
						</t>
						<t>MUST include a "Link" HTTP header containing a link with the "profile" relation type that has as link target the profile URI 
							of the resource representation returned to the user agent. In case the representation conforms to additional profiles known 
							to the server, such a "profile" link SHOULD be included for each.
						</t>
						<t>SHOULD convey the availability of alternate profiled representations of the resource by using the 
							link hint approach described in <xref target="reconneg"/>.
						</t>
					</list>	
					</t>
					
					<t>These requirements for servers that support proactive profile negotiation also apply when:</t>
						<t><list style="symbols">
							<t>The user agent expressed a profile preference in its request by using an "Accept-Profile" header but the server
								cannot return a representation that conforms to a preferred profile.
							</t>
							<t>The user agent did not express a profile preference using an "Accept-Profile" header in its request.
							</t>
						</list></t>
					
					<t>A user agent SHOULD interpret the abscence of a "Vary" HTTP header with an "accept-profile" value in a response from a server 
						as the lack of support for profile negotiation for the resource the user agent interacts with.
					</t>
					
					<t>A server SHOULD consider representations that do not conform to any of the profiles 
						listed by a user agent in an "Accept-Profile" header 
						as non-interpretable by the agent. As such, honoring the user agent preferences in the 
					profile dimension SHOULD take precedence over honoring content negotiation in other dimensions.</t>

					
					<t>						
						In <xref target="Req_proconneg_1"/> a user agent requests an RDF serialization from a server and expresses preference for two 
						media types using the "Accept" header and two profiles using the "Accept-Profile" header. 
						It uses q-values to express a preference for the profile with profile URI 
						&lt;http://example.org/shapes/shape-1&gt; over the one with profile URI &lt;http://example.org/shapes/shape-2&gt;.
					</t>


					<figure title="Client expresses a preference for two profiles" align="left" anchor="Req_proconneg_1">
						<artwork align="left"><![CDATA[ 
GET /document HTTP/1.1
Host: example.org
Accept: text/turtle, application/rdf+xml
Accept-Profile: "http://example.org/shapes/shape-1" ; q=0.8 ,
                "http://example.org/shapes/shape-2" ; q=0.5
Connection: close
]]>
						</artwork>
					</figure>		
					
					<t>						
						<xref target="Res_proconneg_1"/> shows the server's response to the request of <xref target="Req_proconneg_1"/>.
						By means of the "Vary" header, the server expresses support for negotiation in both the media type and profile dimensions. 
						The "profile" link with link target &lt;http://example.org/shapes/shape-2&gt; indicates that the server was able to honor 
						the user agent's second profile preference. Another "profile" link shows that the delivered representation also conforms 
						to a profile with profile URI &lt;http://example.org/shapes/shape-3&gt;. Furthermore, using an "alternate" link, the server indicates 
						support for another profile with &lt;http://example.org/shapes/shape-4&gt; as profile URI. Note that, even if the user agent does not 
						express profile preferences using the "Accept-Profile" header and the server's "Vary" header would be the same, the "Link" header 
						would still include a "profile" link to indicate the profile of the representation returned by the server.
					</t>				
					
					<figure title="Response honors a user agent's preference" align="left" anchor="Res_proconneg_1">
						<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: text/turtle
Vary: Accept, Accept-Profile
Link: <http://example.org/shapes/shape-2> 
      ; rel="profile" , 
      <http://example.org/shapes/shape-3> 
      ; rel="profile" , 
      <http://example.org/document> 
      ; rel="alternate" 
      ; type="text/turtle" 
      ; formats="http://example.org/shapes/shape-4"
Content-Length: 8724
Connection: close

...
]]>
						</artwork>
					</figure>	
					
					<t>						
						<xref target="Res_proconneg_2"/> shows the response to the request of <xref target="Req_proconneg_1"/> in case the server 
						supports profile negotiation for the resource at hand but can not return a representation that conforms to a profile preferred by the user agent. 
						The server has chosen to nevertheless return a representation that conforms to profile &lt;http://example.org/shapes/shape-4&gt;,  
							which is not among the ones preferred by the user agent. The server also reveals the existence of a representation 
							that conforms to profile &lt;http://example.org/shapes/shape-5&gt;. The server could also choose not to return a default 
							representation in which case it would return a "406 Not Acceptable" HTTP response code and no response body. It would not 
							provide any "profile" links but might use "alternate" links with a "formats" attribute to indicate the existence of supported profiles. 
					</t>

					<figure title="Response does not honor a user agent's preference but includes default representation" align="left" anchor="Res_proconneg_2">
						<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: text/turtle
Vary: Accept, Accept-Profile
Link: <http://example.org/shapes/shape-4> 
      ; rel="profile" ,
      <http://example.org/document> 
      ; rel="alternate" 
      ; type="text/turtle" 
      ; formats="http://example.org/shapes/shape-5"
Content-Length: 6333
Connection: close

...
]]>
						</artwork>
					</figure>	

					<t>						
						<xref target="Res_proconneg_3"/> shows the response to the request of <xref target="Req_proconneg_1"/> in case the server 
						does not support profile negotiation for the resource &lt;http://example.org/document&gt;. It does support negotiation in the media type 
						dimension and has honoured one of the user agent's preferences with that regard, as can be seen by the "Vary" and "Content-Type" headers.
					</t>

					<figure title="Response indicates lack of support for proactive profile negotiation" align="left" anchor="Res_proconneg_3">
						<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: text/turtle
Vary: Accept
Content-Length: 8724
Connection: close

...
]]>
						</artwork>
					</figure>						

					
					
				</section>
				
				<section title="Reactive Profile Negotiation" anchor="reconneg">
					
					<t>In reactive profile negotiation, the user agent selects the profiled representation that best meets its preferences 
						on the basis of a list of possible representations it obtains from the server.  A server that supports reactive 
						profile negotiation MUST provide such a list of supported profiled representation as a set of links in the "Link" header. Each of these links:</t>
					
					<t><list style="symbols">
						<t>SHOULD have the "alternate" relation type.</t>
						<t>MUST use the "formats" link hint to convey the profile URI of the profile to which the resource that is the link target conforms.</t>
						<t>SHOULD use the "allow" link hint to convey the HTTP methods that are supported by the resource that is the link target.</t>
					</list></t>
					
					<t><xref target="Req_reconneg_1"/> shows a user agent issuing a HTTP HEAD on a resource in order to determine whether 
						profiled representations are available for it. <xref target="Res_reconneg_1"/> shows the response of a server that 
						supports reactive profile negotiation. By means of "alternate" links in the "Link" header, the server indicates support for 
					    two profiled representations for the resource at hand, and, for each, indicates the URI at which they can be 
					accessed, as well as their respective profile URIs, media types, and supported HTTP methods. On the basis of this response, 
					the client can decide whether any of the linked resources conform to a preferred profile, and, if so, access 
					the respective link target. <xref target="Res_reconneg_2"/> shows the response to an HTTP HEAD issued on the link target 
						&lt;http://example.org/bibrecord/1/DC&gt; of the first "alternate" link.
					</t>

					<figure title="Client determines support for profiles" align="left" anchor="Req_reconneg_1">
						<artwork align="left"><![CDATA[ 
HEAD /bibrecord/1 HTTP/1.1
Host: example.org
Accept: application/xml
Connection: close
]]>
						</artwork>
					</figure>

					<figure title="Server supports two profiles" align="left" anchor="Res_reconneg_1">
						<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: text/plain
Link: <http://example.org/bibrecord/1/DC> 
      ; rel="alternate" 
      ; type="application/xml" 
      ; formats="http://purl.org/dc/terms/"
      ; allow="HEAD,GET,PATCH" ,
      <http://example.org/bibrecord/1/BIBFRAME> 
      ; rel="alternate" 
      ; formats="http://id.loc.gov/ontologies/bibframe/"
      ; allow="HEAD,GET"
Content-Length: 200
Connection: close
]]>
						</artwork>
					</figure>
					
					<figure title="Response to a client accessesing a profiled representation" align="left" anchor="Res_reconneg_2">
						<artwork align="left"><![CDATA[ 
HTTP/1.1 200 OK
Content-Type: application/xml
Link: <http://purl.org/dc/terms/>
      ; rel="profile" ,
      <http://example.org/bibrecord/1/BIBFRAME> 
      ; rel="alternate" 
      ; formats="http://id.loc.gov/ontologies/bibframe/"
      ; allow="HEAD,GET"
Allow: HEAD, GET, PATCH
Accept-Patch: application/xml-patch+xml
Content-Length: 458
Connection: close
]]>
						</artwork>
					</figure>
					
				</section>	
		
			</section>
			<section title="Accept-Profile Header Syntax" anchor="accept-profile">
				<t>The "Accept-Profile" header field specifies one or more
					content profiles the issuing agent accepts for processing.
					If an "Accept-Profile" field is present,
					it MUST contain a comma-separated list of profile URIs.
					Each profile MUST be identified by an absolute URI reference inside angle brackets ("&lt;&gt;").
					Quality values as defined in <xref target="RFC7230">Section 5.3.1 of RFC 7230</xref>
					MAY be used to assign a relative "weight" to the preference.
					Exactly how that weight is used to determine the best representation
					is beyond the scope of this specification.</t>
				<t>A request without "Accept-Profile" header field
					SHOULD indicate that the recipient
					accepts content conforming to any profile.
					If the header field is present in a user agent request
					and the server cannot provide a representation
					that conforms to the specified profile,
					it SHOULD either honor the header field by responding with a 406 (Not Acceptable) status code,
					or disregard the header field by treating the	response as if it is not subject to content negotiation.
					If the server does not support profile-based content negotiation,
					the latter behavior SHOULD also be followed.
					Regardless of the outcomes of the negotiation process,
					if the server knows that the representation conforms to one or more profiles,
					it SHOULD list them in the "Content-Profile" header of the response.</t>
				<t>The absence of an "Accept-Profile" header field in an HTTP response
					SHOULD be taken as an indication
					that the server does not support profiles for the given resource.
					It MUST NOT be seen as an indication
					that the server handles payloads conforming to any profile.</t>
				<t>An agent that wants to indicate that several profiles are acceptable,
					can either submit one Accept-Profile field for every profile that is acceptable
					(possibly specifying q-values for each profile URI)
					or it can decide to combine all profile URIs into a comma-separated list
					and send that list in a single Accept-Profile field.
				  Differences in ordering of the items in this list,
					or the presence of duplicates,
					MUST NOT be interpreted as semantically significant.
				  Instead of sending a comma-separated list of profile URIs in one "Accept-Profile" header field,
					and agent MAY choose to send each profile URI in its own "Content-Profile" header field
					without changing its meaning,
					as specified in <xref target="RFC7230">Section 3.2.2 of RFC 7230</xref>.</t>
				<t><xref target="abnf_accept_profile"/> describes the syntax (Augmented Backus-Naur Form)
					of the Accept-Profile header fields,
					using the grammar defined in <xref target="RFC5234">RFC 5234</xref> and the rules
					defined in <xref target="RFC7230">Section 3.2 of RFC 7230</xref>.
					The definitions of "URI-reference" and "weight" are imported from
					<xref target="RFC7230">RFC 7230</xref> and <xref target="RFC7231">RFC 7231</xref>,
					respectively.</t>
				
				<figure title="ABNF for the &quot;Accept-Profile&quot; HTTP header" anchor="abnf_accept_profile" align="left">
					<artwork align="left" type="abnf"><![CDATA[
Accept-Profile = "Accept-Profile" ":"
OWS (accept-value) *(OWS "," OWS accept-value) OWS
accept-value = "<" URI-reference ">" [weight] | accept-value-ext
]]>
					</artwork>
				</figure>
			</section>
			
		</section>
		<section title="Content Negotiation" anchor="Negotiating">
			<section title="Mechanisms">
				<t>user agents and servers supporting profiles
					can agree on mutually acceptable profiles for the payload
					through the content negotiation processes described in
					<xref target="RFC7231">Section 3.4 of RFC 7231</xref>.
					The present document does not define or alter content negotiation,
					but rather adds an additional dimension to the content negotiation process.
					Agents can indicate their preferences for certain profiles
					by specifying an "Accept-Profile" header on requests,
					and servers indicate their choice
					by specifying a "Content-Profile" header on responses.
					Both proactive negotiation and reactive negotiation for profiles
					can be supported by servers.</t>
				<t>Although servers are free to implement negotiation as they see fit,
					if the user agent sends an "Accept-Profile" header,
					they SHOULD consider representations not conforming to any of the listed profiles
					as non-interpretable by the client.
					This means that a representation that conforms to a listed profile,
					but has a low preference score on other dimensions,
					SHOULD be considered as more desired
					than a representation with a higher preference score on other dimensions
					but that does not conform to any listed profile.
					If no "Accept-Profile" header preference is given,
					the profile dimension SHOULD be ignored for negotiation purposes.
					Nonetheless, in all cases, the server's response
					SHOULD contain a "Content-Profile" header
					listing the URIs of all profiles to which it knows the representation conforms.</t>
				<t>A server that fails a request due to receiving a payload with an unsupported profile
					SHOULD respond with a 415 status and
					SHOULD include an "Accept-Profile" header in its response,
					allowing clients to distinguish between issues related to profiles and media types.
					In order to avoid confusion with issues related to media types,
					servers that fail a request with a 415 status for reasons unrelated to profiles
					MUST NOT include the "Accept-Profile" header field.</t>
				<t></t>
			</section>
			<section title="Examples">
				<t>The following examples show possible exchanges of profile information between a user agent
				and a server. For clarity, the examples only contain minimal information, i.e.,
				only the relevant headers are included and message bodies are ignored.
</t>
					<figure align="left" anchor="example_server_indicates_profiles">
						<preamble>
							In this first example,
							a user agent requests a JSON representation.
							The server returns a JSON representation,
							and indicates that it conforms to additional structural constraints
							as specified in a profile identified by "urn:example:schema:e-commerce-payment".
							Based on this information,
							the client can choose to use a JSON parser,
							and can rely on additional assumptions
							about the structure and semantics of the resulting JSON tree.
						</preamble>
<artwork align="left">
Request:

  GET /document HTTP/1.1
  Accept: application/json

Response:

  HTTP/1.1 200 OK
  Content-Type: application/json
  Content-Profile: &lt;urn:example:schema:e-commerce-payment&gt;

</artwork>
					</figure>

					<figure align="left" anchor="example_both_support_profiles">
						<preamble>
							Another user agent requests a JSON representation conforming to additional constraints,
							as specified in a profile identified by "urn:example:schema:e-commerce-payment".
							The server has such a representation of the resource available,
							as well as an XML representation conforming to the same profile,
							and another JSON representation conforming to a different profile.
						</preamble>
<artwork align="left">
Request:
  GET /document HTTP/1.1
  Accept: application/json
  Accept-Profile: &lt;urn:example:schema:e-commerce-payment&gt;

Response:
  HTTP/1.1 200 OK
  Content-Type: application/json
  Content-Profile: &lt;urn:example:schema:e-commerce-payment&gt;
  Link: rel="self";
          type="application/json";
          profile="urn:example:schema:e-commerce-payment",
        rel="alternate";
          type="application/xml";
          profile="urn:example:schema:e-commerce-payment",
        rel="alternate";
          type="application/json";
          profile="urn:example:schema:e-commerce-accounting"
</artwork>
					</figure>

					<figure align="left" anchor="example_server_prefers_other">
						<preamble>
							A user agent requests an RDF document conforming to one of two RDF Shapes.
							It uses q-values to express a preference for shape-1.
							The server, however, prefers to deliver in shape-2,
							and the response also happens to conform to shape-3.
						</preamble>
<artwork align="left">
Request:
  GET /document HTTP/1.1
  Accept: text/turtle, application/rdf+xml
  Accept-Profile: &lt;http://example.com/shapes/shape-1&gt;;q=0.8,
                  &lt;http://example.com/shapes/shape-2&gt;;q=0.5

Response:
  HTTP/1.1 200 OK
  Content-Type: text/turtle
  Content-Profile: &lt;http://example.com/shapes/shape-2&gt;,
                   &lt;http://example.com/shapes/shape-3&gt;
  Link: rel="self";
          type="text/turtle";
          profile="http://example.com/shapes/shape-2
                   http://example.com/shapes/shape-3",
        rel="alternate";
          type="text/turtle";
          profile="http://example.com/shapes/shape-4"
</artwork>
					</figure>

					<figure align="left" anchor="example_406">
						<preamble>
							A user agent requests an RDF document conforming to one of two RDF Shapes.
							The server, however, does not support these profiles.
						</preamble>
<artwork align="left">
Request:
  GET /document HTTP/1.1
  Accept: text/turtle, application/rdf+xml
  Accept-Profile: &lt;http://example.com/shapes/shape-1&gt;;q=0.8,
                  &lt;http://example.com/shapes/shape-2&gt;;q=0.5

Response:
  HTTP/1.1 406 Not Acceptable
  Content-Type: text/html
  Link: rel="alternate";
          type="text/turtle";
          profile="http://example.com/shapes/shape-4"
</artwork>
					</figure>

					<figure align="left" anchor="example_415">
						<preamble>
							A user agent PUTs an RDF document conforming to the RDF Shape
							identified by http://example.com/shapes/shape-1.
							The server answers that it can only process
							documents conforming to http://example.com/shapes/shape-2.
							The user agent knows the problem is caused by the profile,
							because the "Accept-Profile" header is listed.
						</preamble>
<artwork align="left">
Request:
  PUT /document HTTP/1.1
  Content-Type: text/turtle
  Content-Profile: &lt;http://example.com/shapes/shape-1&gt;

Response:
  HTTP/1.1 415 Unsupported Media Type
  Content-Type: text/html
  Accept-Profile: &lt;http://example.com/shapes/shape-2&gt;
</artwork>
					</figure>
			</section>
		</section>

		<section title="IANA Considerations">
			
			<t>
				This memo requires IANA to register the Accept-Profile HTTP header defined in 
				<xref target="accept-profile"></xref> in the appropriate IANA registry:
			</t>
				<t><list style="symbols">
				<t>Header Field Name: Accept-Profile</t>
				<t>Applicable Protocol: Hypertext Transfer Protocol (HTTP)</t>
				<t>Status: Informational</t>
				<t>Author/Change controller: IETF</t>
				<t>Specification document(s): this document</t>
				</list></t>
				
		
			<!--
			<section title="Content-Profile HTTP Header Registration"></section>
			-->
		</section>
		<section anchor="Security" title="Security Considerations">
			<t>The use of HTTP to negotiate and transport profile information
				implies that all privacy and security issues that are relevant for that protocol
				are also relevant for profile negotiation.
				E. g., information such as user agent, accept-headers, IP address etc.
				can potentially be used as identifying information,
				and particularly, the IP address adds information about geolocation and institutional membership.
				Further, offering a list of acceptable profiles at the beginning of a negotiation process
				can reveal information about the user's interests
				that could be used to add such information to a user profile.
				If this is undesirable, a client and/or a server can stop exposing the header,
				in which case HTTP interactions would be back to the level of standard HTTP
				(i.e., with no indication what profiles
				the	user agent or the server prefer and/or can handle).</t>
		</section>
		
			
		
	</middle>

	<back>
		<references title="Normative References">
			&RFC2119;
			&RFC5234;
			&RFC7230;
			&RFC6838;
			&RFC7231;
			&I-D.nottingham-link-hint;
			&RFC6906;
		</references>

		<references title="Informative References">
			&RFC4452;
			&RFC8141;
			&RFC8288;
			&RFC5988;
			&SHACL;
			&XSD;
			<!--
			<reference anchor="DSP" target="http://dublincore.org/documents/dc-dsp/">
				<front>
					<title>Description Set Profiles: A constraint language for Dublin Core Application Profiles</title>

					<author initials="M." surname="Nilsson">
						<organization>KTH</organization>
					</author>
					<date year="2008" />
				</front>
			</reference>
			-->
			<reference anchor="HeeryAndPatel" target="http://www.ariadne.ac.uk/issue25/app-profiles">
				<front>
					<title>Application Profiles: Mixing and Matching Metadata Schemas</title>
					<author initials="R." surname="Heery">
						<organization>UK Office for Library and Information networking (UKOLN), University of Bath</organization>
					</author>
					<author initials="M." surname="Patel">
						<organization>UK Office for Library and Information networking (UKOLN), University of Bath</organization>
					</author>
					<date year="2000"/>
				</front>
			</reference>
		</references>
	</back>
</rfc>
